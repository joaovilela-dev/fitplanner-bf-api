"""
Sistema ENSEMBLE de predi√ß√£o de Body Fat - V2 MELHORADO
Combina 3 m√©todos com ajuste din√¢mico de pesos:
1. Modelo ML (Random Forest)
2. Regras fisiol√≥gicas
3. An√°lise de textura/defini√ß√£o muscular

üÜï V2: Ajuste inteligente de pesos baseado em casos especiais e inconsist√™ncias
"""

import numpy as np
from typing import Optional


def ensemble_predict_body_fat(
    ml_prediction: float,
    rules_prediction: float,
    texture_data: dict,
    bmi: float,
    sex: str,
    measurements: dict,
    ratios: dict,
    confidence_threshold: float = 0.6
) -> dict:
    """
    Predi√ß√£o ENSEMBLE com ajuste din√¢mico de pesos.
    
    üÜï V2 Features:
    - Detec√ß√£o de 5 casos especiais
    - Redu√ß√£o autom√°tica do peso do ML quando diverge das regras
    - Corre√ß√£o de inconsist√™ncias fisiol√≥gicas (BMI vs BF)
    - Pesos originais salvos para compara√ß√£o
    
    Args:
        ml_prediction: Predi√ß√£o do modelo ML
        rules_prediction: Predi√ß√£o baseada em regras
        texture_data: Dados de an√°lise de textura
        bmi: √çndice de Massa Corporal
        sex: "male" ou "female"
        measurements: Medi√ß√µes corporais
        ratios: Raz√µes corporais
        confidence_threshold: Threshold para usar apenas m√©todos confi√°veis
    
    Returns:
        {
            "final_prediction": float,
            "ml_prediction": float,
            "rules_prediction": float,
            "texture_prediction": float,
            "ensemble_weights": dict (pesos ajustados),
            "original_weights": dict (pesos antes dos ajustes),
            "confidence": float,
            "method_used": str,
            "adjustments": list,
            "special_cases": dict
        }
    """
    
    adjustments = []
    
    # ===================================
    # 1Ô∏è‚É£ PREDI√á√ÉO BASEADA EM TEXTURA
    # ===================================
    from app.services.texture_analyzer import estimate_bf_from_definition
    texture_prediction = estimate_bf_from_definition(texture_data, sex, bmi)
    
    # ===================================
    # 2Ô∏è‚É£ CALCULAR CONFIAN√áA INICIAL
    # ===================================
    
    # ML: Confian√ßa baseada em features dentro do range de treinamento
    ml_confidence = _calculate_ml_confidence(measurements, ratios, bmi)
    
    # Regras: Sempre tem confian√ßa moderada
    rules_confidence = 0.7
    
    # Textura: Confian√ßa da an√°lise de imagem
    texture_confidence = texture_data.get("confidence", 0.5)
    
    # Salvar pesos originais para compara√ß√£o
    original_ml_conf = ml_confidence
    original_rules_conf = rules_confidence
    original_texture_conf = texture_confidence
    
    print(f"\nüìä ENSEMBLE V2 - Confian√ßas Iniciais:")
    print(f"   ML:      {ml_confidence:.2f}")
    print(f"   Regras:  {rules_confidence:.2f}")
    print(f"   Textura: {texture_confidence:.2f}")
    
    # ===================================
    # 3Ô∏è‚É£ DETECTAR DIVERG√äNCIAS EXTREMAS
    # ===================================
    predictions = [ml_prediction, rules_prediction, texture_prediction]
    pred_std = np.std(predictions)
    
    if pred_std > 8:  # Diverg√™ncia muito alta (>8%)
        adjustments.append(
            f"‚ö†Ô∏è Alta diverg√™ncia entre m√©todos (std={pred_std:.1f}%)"
        )
        print(f"   ‚ö†Ô∏è DIVERG√äNCIA ALTA: {pred_std:.1f}%")
    
    # ===================================
    # üÜï 4Ô∏è‚É£ DETEC√á√ÉO DE CASOS ESPECIAIS E AJUSTES
    # ===================================
    
    # Extrair m√©tricas relevantes
    definition_score = texture_data.get("definition_score", 0.5)
    abs_visibility = texture_data.get("abs_visibility", 0.5)
    waist_to_shoulder = ratios.get("waist_to_shoulder", 0.6)
    volume_indicator = measurements.get("volume_indicator", 0.15)
    
    # --- CASO 1: ATLETA ---
    is_athlete = (
        definition_score > 0.65 and
        abs_visibility > 0.60 and
        20 <= bmi <= 26
    )
    
    if is_athlete:
        adjustments.append("üèãÔ∏è F√≠sico atl√©tico detectado - Priorizando an√°lise visual")
        print("   üèãÔ∏è ATLETA DETECTADO")
        
        # Aumentar peso da textura, reduzir ML
        texture_confidence = min(texture_confidence * 1.4, 1.0)  # +40%
        ml_confidence *= 0.65  # -35%
        rules_confidence *= 0.9  # -10%
    
    # --- CASO 2: SOBREPESO ---
    is_overweight = (
        bmi > 28 and
        waist_to_shoulder > 0.65
    )
    
    if is_overweight:
        adjustments.append("üìà Sobrepeso detectado - Priorizando regras fisiol√≥gicas")
        print("   üìà SOBREPESO DETECTADO")
        
        # Aumentar peso das regras, reduzir textura
        rules_confidence = min(rules_confidence * 1.5, 1.0)  # +50%
        texture_confidence *= 0.7  # -30%
        ml_confidence *= 0.8  # -20%
    
    # --- CASO 3: DIVERG√äNCIA ML vs REGRAS ---
    ml_rules_diff = abs(ml_prediction - rules_prediction)
    
    if ml_rules_diff > 10:
        adjustments.append(f"‚ö†Ô∏è Alta diverg√™ncia ML vs Regras ({ml_rules_diff:.1f}%)")
        print(f"   ‚ö†Ô∏è ML vs Regras: diferen√ßa de {ml_rules_diff:.1f}% - Reduzindo peso do ML")
        
        # ML provavelmente est√° errado
        ml_confidence *= 0.5  # -50%
        rules_confidence = min(rules_confidence * 1.3, 1.0)  # +30%
    
    # --- üÜï CASO 4: INCONSIST√äNCIA BMI BAIXO + BF ALTO ---
    is_low_bmi_high_bf = (
        bmi < 22 and
        ml_prediction > 20
    )
    
    if is_low_bmi_high_bf:
        adjustments.append(
            f"‚ö†Ô∏è Inconsist√™ncia: BMI baixo ({bmi:.1f}) mas ML prev√™ BF alto ({ml_prediction:.1f}%)"
        )
        print(f"   ‚ö†Ô∏è BMI BAIXO + BF ALTO DETECTADO")
        
        # ML est√° claramente errado
        ml_confidence *= 0.4  # -60%
        rules_confidence = min(rules_confidence * 1.4, 1.0)  # +40%
        texture_confidence = min(texture_confidence * 1.3, 1.0)  # +30%
    
    # --- üÜï CASO 5: INCONSIST√äNCIA BMI ALTO + BF BAIXO ---
    is_high_bmi_low_bf = (
        bmi > 28 and
        ml_prediction < 20
    )
    
    if is_high_bmi_low_bf:
        adjustments.append(
            f"‚ö†Ô∏è Inconsist√™ncia: BMI alto ({bmi:.1f}) mas ML prev√™ BF baixo ({ml_prediction:.1f}%)"
        )
        print(f"   ‚ö†Ô∏è BMI ALTO + BF BAIXO DETECTADO")
        
        # ML est√° claramente errado
        ml_confidence *= 0.4  # -60%
        rules_confidence = min(rules_confidence * 1.5, 1.0)  # +50%
    
    # --- CASO 6: IMAGEM DE BAIXA QUALIDADE ---
    if texture_confidence < 0.4:
        adjustments.append("üì∏ Qualidade de imagem baixa - Priorizando antropometria")
        print("   üì∏ BAIXA QUALIDADE DE IMAGEM")
        
        ml_confidence = min(ml_confidence * 1.2, 1.0)  # +20%
        rules_confidence = min(rules_confidence * 1.1, 1.0)  # +10%
        texture_confidence *= 0.8  # -20%
    
    # ===================================
    # 5Ô∏è‚É£ NORMALIZAR CONFIAN√áAS
    # ===================================
    total_confidence = ml_confidence + rules_confidence + texture_confidence
    
    if total_confidence > 0:
        ml_weight = ml_confidence / total_confidence
        rules_weight = rules_confidence / total_confidence
        texture_weight = texture_confidence / total_confidence
    else:
        # Fallback: pesos iguais
        ml_weight = rules_weight = texture_weight = 1/3
    
    # Calcular pesos originais (antes dos ajustes)
    original_total = original_ml_conf + original_rules_conf + original_texture_conf
    original_ml_weight = original_ml_conf / original_total
    original_rules_weight = original_rules_conf / original_total
    original_texture_weight = original_texture_conf / original_total
    
    # üÜï LOG de mudan√ßas de pesos
    print(f"\nüéØ ENSEMBLE V2 - Ajustes de Pesos:")
    print(f"   ML:      {original_ml_weight:.3f} ‚Üí {ml_weight:.3f} ({(ml_weight-original_ml_weight)*100:+.1f}%)")
    print(f"   Regras:  {original_rules_weight:.3f} ‚Üí {rules_weight:.3f} ({(rules_weight-original_rules_weight)*100:+.1f}%)")
    print(f"   Textura: {original_texture_weight:.3f} ‚Üí {texture_weight:.3f} ({(texture_weight-original_texture_weight)*100:+.1f}%)")
    
    # ===================================
    # 6Ô∏è‚É£ ENSEMBLE - VOTA√á√ÉO PONDERADA
    # ===================================
    ensemble_prediction = (
        ml_prediction * ml_weight +
        rules_prediction * rules_weight +
        texture_prediction * texture_weight
    )
    
    print(f"\nüéØ ENSEMBLE V2 - Predi√ß√µes:")
    print(f"   ML:      {ml_prediction:.1f}% (peso {ml_weight:.2f})")
    print(f"   Regras:  {rules_prediction:.1f}% (peso {rules_weight:.2f})")
    print(f"   Textura: {texture_prediction:.1f}% (peso {texture_weight:.2f})")
    print(f"   ‚Üí ENSEMBLE: {ensemble_prediction:.1f}%")
    
    # ===================================
    # 7Ô∏è‚É£ VALIDA√á√ÉO FISIOL√ìGICA FINAL
    # ===================================
    from app.services.bf_validator import validate_and_adjust_bf
    
    validation = validate_and_adjust_bf(
        bf_prediction=ensemble_prediction,
        bmi=bmi,
        sex=sex,
        measurements=measurements,
        ratios=ratios
    )
    
    final_prediction = validation["adjusted_bf"]
    
    if validation["was_adjusted"]:
        adjustments.append(
            f"üîß Valida√ß√£o final: {ensemble_prediction:.1f}% ‚Üí {final_prediction:.1f}% "
            f"({validation['reason']})"
        )
        print(f"   üîß VALIDA√á√ÉO: {ensemble_prediction:.1f}% ‚Üí {final_prediction:.1f}%")
    
    print(f"   ‚úÖ FINAL: {final_prediction:.1f}%")
    
    # ===================================
    # 8Ô∏è‚É£ CONFIAN√áA FINAL
    # ===================================
    # Confian√ßa √© maior quando m√©todos concordam
    agreement = 1.0 - (pred_std / 20)  # Penalizar diverg√™ncia
    avg_confidence = (ml_confidence + rules_confidence + texture_confidence) / 3
    
    final_confidence = (agreement * 0.6 + avg_confidence * 0.4)
    final_confidence = max(0.3, min(final_confidence, 1.0))
    
    # ===================================
    # üÜï RESULTADO COM PESOS ORIGINAIS
    # ===================================
    return {
        "final_prediction": round(final_prediction, 1),
        "ml_prediction": round(ml_prediction, 1),
        "rules_prediction": round(rules_prediction, 1),
        "texture_prediction": round(texture_prediction, 1),
        "ensemble_raw": round(ensemble_prediction, 1),
        
        # üÜï Pesos ajustados
        "ensemble_weights": {
            "ml": round(ml_weight, 3),
            "rules": round(rules_weight, 3),
            "texture": round(texture_weight, 3)
        },
        
        # üÜï Pesos originais (antes dos ajustes)
        "original_weights": {
            "ml": round(original_ml_weight, 3),
            "rules": round(original_rules_weight, 3),
            "texture": round(original_texture_weight, 3)
        },
        
        # üÜï Diferen√ßas de pesos
        "weight_changes": {
            "ml": round((ml_weight - original_ml_weight) * 100, 1),
            "rules": round((rules_weight - original_rules_weight) * 100, 1),
            "texture": round((texture_weight - original_texture_weight) * 100, 1)
        },
        
        "confidence": round(final_confidence, 2),
        "confidence_level": _get_confidence_level(final_confidence),
        "method_used": "Ensemble V2 (ML + Rules + Texture + Dynamic Weights)",
        "adjustments": adjustments,
        "texture_analysis": texture_data,
        
        # üÜï Casos especiais detectados
        "special_cases": {
            "is_athlete": is_athlete,
            "is_overweight": is_overweight,
            "low_bmi_high_bf": is_low_bmi_high_bf,
            "high_bmi_low_bf": is_high_bmi_low_bf,
            "low_image_quality": texture_confidence < 0.4,
            "ml_rules_divergence": ml_rules_diff > 10
        }
    }


def _calculate_ml_confidence(measurements: dict, ratios: dict, bmi: float) -> float:
    """
    Calcula confian√ßa do modelo ML baseado em:
    - Features dentro do range de treinamento
    - Qualidade das medi√ß√µes
    """
    
    confidence = 1.0
    
    # BMI t√≠pico: 18-35
    if bmi < 18 or bmi > 35:
        confidence *= 0.8
    
    # Waist ratio t√≠pico: 0.40-0.75
    waist_ratio = ratios.get("waist_to_shoulder", 0.6)
    if waist_ratio < 0.35 or waist_ratio > 0.80:
        confidence *= 0.85
    
    # Volume indicator t√≠pico: 0.12-0.30
    volume = measurements.get("volume_indicator", 0.15)
    if volume < 0.10 or volume > 0.35:
        confidence *= 0.9
    
    return confidence


def _get_confidence_level(confidence: float) -> str:
    """Retorna n√≠vel textual de confian√ßa"""
    if confidence >= 0.85:
        return "Muito Alta"
    elif confidence >= 0.70:
        return "Alta"
    elif confidence >= 0.55:
        return "M√©dia"
    elif confidence >= 0.40:
        return "Baixa"
    else:
        return "Muito Baixa"