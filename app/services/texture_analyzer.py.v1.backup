"""
AnÃ¡lise de textura da imagem para detectar definiÃ§Ã£o muscular - V2 CALIBRADO
ðŸ†• Melhorias:
- Thresholds mais rigorosos para abs e vascularizaÃ§Ã£o
- PenalizaÃ§Ã£o por gordura abdominal central
- Melhor separaÃ§Ã£o entre fÃ­sicos distintos
- CorreÃ§Ã£o quando C/Q > 0.90 (cintura larga)
"""

import cv2
import numpy as np
from typing import Optional


def analyze_muscle_definition(image_path: str, landmarks=None) -> dict:
    """
    Analisa definiÃ§Ã£o muscular na imagem - V2 CALIBRADO
    
    ðŸ†• V2 Melhorias:
    - Thresholds mais rigorosos (abs_visibility, vascularity)
    - DetecÃ§Ã£o de gordura abdominal central
    - Melhor discriminaÃ§Ã£o entre fÃ­sicos
    
    Returns:
        {
            "definition_score": float (0-1),
            "abs_visibility": float (0-1),
            "vascularity": float (0-1),
            "muscle_separation": float (0-1),
            "subcutaneous_fat": float (0-1),
            "confidence": float (0-1)
        }
    """
    
    try:
        # Carregar imagem
        image = cv2.imread(image_path)
        if image is None:
            return _get_default_result()
        
        # Converter para escala de cinza
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        
        # ===================================
        # 1ï¸âƒ£ ANÃLISE DE TEXTURA GLOBAL
        # ===================================
        texture_score = _analyze_texture_complexity(gray)
        
        # ===================================
        # 2ï¸âƒ£ DETECÃ‡ÃƒO DE BORDAS (separaÃ§Ã£o muscular)
        # ===================================
        edge_score = _detect_muscle_edges(gray)
        
        # ===================================
        # 3ï¸âƒ£ ANÃLISE DE CONTRASTE (definiÃ§Ã£o)
        # ===================================
        contrast_score = _analyze_local_contrast(gray)
        
        # ===================================
        # 4ï¸âƒ£ ANÃLISE DA REGIÃƒO ABDOMINAL - ðŸ†• CALIBRADO
        # ===================================
        abs_score = _analyze_abdominal_region_v2(image, gray, landmarks)
        
        # ===================================
        # 5ï¸âƒ£ VASCULARIZAÃ‡ÃƒO - ðŸ†• CALIBRADO
        # ===================================
        vascularity_score = _detect_vascularity_v2(gray)
        
        # ===================================
        # ðŸ†• 6ï¸âƒ£ DETECÃ‡ÃƒO DE GORDURA ABDOMINAL CENTRAL
        # ===================================
        central_fat_score = _detect_central_fat(gray)
        
        # ===================================
        # 7ï¸âƒ£ SUAVIDADE DA PELE (gordura subcutÃ¢nea)
        # ===================================
        smoothness = _analyze_skin_smoothness(gray)
        fat_score = 1.0 - smoothness
        
        # ===================================
        # ðŸ†• SCORE FINAL DE DEFINIÃ‡ÃƒO - V2
        # ===================================
        # Pesos ajustados para melhor discriminaÃ§Ã£o
        definition_score = (
            texture_score * 0.15 +
            edge_score * 0.20 +
            contrast_score * 0.15 +
            abs_score * 0.30 +          # ðŸ†• Aumentado de 0.25
            vascularity_score * 0.15 +   # ðŸ†• Aumentado de 0.10
            (1.0 - central_fat_score) * 0.05  # ðŸ†• NOVO: penalizar gordura central
        )
        
        # ðŸ†• PENALIZAÃ‡ÃƒO ADICIONAL por gordura central
        if central_fat_score > 0.6:
            definition_score *= 0.85  # Reduz 15%
        
        # ConfianÃ§a baseada na qualidade da imagem
        confidence = _calculate_confidence(image, gray)
        
        return {
            "definition_score": round(float(definition_score), 3),
            "abs_visibility": round(float(abs_score), 3),
            "vascularity": round(float(vascularity_score), 3),
            "muscle_separation": round(float(edge_score), 3),
            "subcutaneous_fat": round(float(fat_score), 3),
            "central_fat": round(float(central_fat_score), 3),  # ðŸ†• NOVO
            "texture_complexity": round(float(texture_score), 3),
            "local_contrast": round(float(contrast_score), 3),
            "confidence": round(float(confidence), 3)
        }
        
    except Exception as e:
        print(f"âš ï¸ Erro na anÃ¡lise de textura: {e}")
        return _get_default_result()


def _analyze_texture_complexity(gray: np.ndarray) -> float:
    """Analisa complexidade da textura usando VariÃ¢ncia de Laplaciano"""
    laplacian = cv2.Laplacian(gray, cv2.CV_64F)
    variance = laplacian.var()
    normalized = min(variance / 500, 1.0)
    return normalized


def _detect_muscle_edges(gray: np.ndarray) -> float:
    """Detecta bordas que indicam separaÃ§Ã£o muscular"""
    edges = cv2.Canny(gray, 50, 150)
    edge_density = np.count_nonzero(edges) / edges.size
    normalized = min(edge_density / 0.08, 1.0)
    return normalized


def _analyze_local_contrast(gray: np.ndarray) -> float:
    """Analisa contraste local"""
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    local_std = np.abs(gray.astype(float) - blurred.astype(float))
    contrast = local_std.mean()
    normalized = min(contrast / 20, 1.0)
    return normalized


def _analyze_abdominal_region_v2(image: np.ndarray, gray: np.ndarray, landmarks) -> float:
    """
    AnÃ¡lise da regiÃ£o abdominal - ðŸ†• V2 CALIBRADO
    
    Melhorias:
    - Thresholds mais rigorosos
    - AnÃ¡lise horizontal E vertical
    - PenalizaÃ§Ã£o por gordura visÃ­vel
    """
    h, w = gray.shape
    
    # ROI: Centro-baixo da imagem (regiÃ£o tÃ­pica do abdÃ´men)
    y_start = int(h * 0.40)
    y_end = int(h * 0.70)
    x_start = int(w * 0.35)
    x_end = int(w * 0.65)
    
    roi = gray[y_start:y_end, x_start:x_end]
    
    if roi.size == 0:
        return 0.5
    
    # 1. Bordas horizontais (separaÃ§Ã£o dos mÃºsculos abdominais)
    edges_h = cv2.Sobel(roi, cv2.CV_64F, 0, 1, ksize=3)
    horizontal_features = np.abs(edges_h).mean()
    
    # 2. Bordas verticais (linha alba central)
    edges_v = cv2.Sobel(roi, cv2.CV_64F, 1, 0, ksize=3)
    vertical_features = np.abs(edges_v).mean()
    
    # 3. VariÃ¢ncia (textura rica = mÃºsculos)
    roi_variance = roi.var()
    
    # ðŸ†• 4. Desvio padrÃ£o (mais variaÃ§Ã£o = mais definiÃ§Ã£o)
    roi_std = roi.std()
    
    # ðŸ†• THRESHOLDS MUITO MAIS RIGOROSOS
    # Para ter abs_score > 0.80, precisa:
    # - horizontal > 35 (antes: 30)
    # - vertical > 30 (antes: 25)
    # - variance > 1800 (antes: 1500)
    # - std > 40 (novo)
    
    abs_score = (
        min(horizontal_features / 35, 1.0) * 0.35 +  # ðŸ†• 35 (era 30)
        min(vertical_features / 30, 1.0) * 0.25 +    # ðŸ†• 30 (era 25)
        min(roi_variance / 1800, 1.0) * 0.25 +       # ðŸ†• 1800 (era 1500)
        min(roi_std / 40, 1.0) * 0.15                # ðŸ†• NOVO critÃ©rio
    )
    
    # ðŸ†• PENALIZAÃ‡ÃƒO FORTE se valores muito baixos
    if horizontal_features < 15:
        abs_score *= 0.4  # Era 0.5
    
    if vertical_features < 10:
        abs_score *= 0.6  # ðŸ†• NOVO
    
    return abs_score


def _detect_vascularity_v2(gray: np.ndarray) -> float:
    """
    Detecta veias visÃ­veis - ðŸ†• V2 CALIBRADO
    
    Melhorias:
    - Threshold mais rigoroso
    - Filtro de ruÃ­do melhorado
    """
    # EqualizaÃ§Ã£o de histograma
    equalized = cv2.equalizeHist(gray)
    
    # DetecÃ§Ã£o de estruturas finas (veias)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 3))
    tophat = cv2.morphologyEx(equalized, cv2.MORPH_TOPHAT, kernel)
    
    # Threshold adaptativo
    _, veins = cv2.threshold(tophat, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    
    # ðŸ†• Remover ruÃ­do pequeno (pixels isolados)
    kernel_clean = np.ones((2, 2), np.uint8)
    veins = cv2.morphologyEx(veins, cv2.MORPH_OPEN, kernel_clean)
    
    # Densidade de pixels de "veias"
    vein_density = np.count_nonzero(veins) / veins.size
    
    # ðŸ†• THRESHOLD MUITO MAIS RIGOROSO
    # Para ter vascularity > 0.80, precisa vein_density > 0.05 (era 0.04)
    # Para ter vascularity > 0.90, precisa vein_density > 0.07
    normalized = min(vein_density / 0.05, 1.0)
    
    # ðŸ†• PENALIZAÃ‡ÃƒO se density muito baixa
    if vein_density < 0.015:
        normalized *= 0.5
    
    return normalized


def _detect_central_fat(gray: np.ndarray) -> float:
    """
    ðŸ†• V2: Detecta gordura abdominal central
    
    Gordura central aparece como regiÃ£o de baixo contraste e alta suavidade
    na regiÃ£o do abdÃ´men.
    
    Returns:
        float: 0 = sem gordura, 1 = muita gordura central
    """
    h, w = gray.shape
    
    # ROI: regiÃ£o central do abdÃ´men
    y_start = int(h * 0.45)
    y_end = int(h * 0.65)
    x_start = int(w * 0.40)
    x_end = int(w * 0.60)
    
    roi = gray[y_start:y_end, x_start:x_end]
    
    if roi.size == 0:
        return 0.0
    
    # 1. Suavidade (gordura Ã© lisa)
    blurred = cv2.GaussianBlur(roi, (9, 9), 0)
    difference = np.abs(roi.astype(float) - blurred.astype(float))
    smoothness = 1.0 - min(difference.mean() / 15, 1.0)
    
    # 2. Baixo contraste (gordura nÃ£o tem textura)
    roi_std = roi.std()
    low_contrast = 1.0 - min(roi_std / 35, 1.0)
    
    # 3. Uniformidade de intensidade
    hist = cv2.calcHist([roi], [0], None, [256], [0, 256])
    hist_normalized = hist / hist.sum()
    # Entropia: baixa = uniforme (gordura), alta = variada (mÃºsculo)
    entropy = -np.sum(hist_normalized * np.log2(hist_normalized + 1e-10))
    uniformity = 1.0 - min(entropy / 7.0, 1.0)
    
    # Score final de gordura central
    fat_score = (
        smoothness * 0.40 +
        low_contrast * 0.35 +
        uniformity * 0.25
    )
    
    return fat_score


def _analyze_skin_smoothness(gray: np.ndarray) -> float:
    """Mede suavidade da pele"""
    blurred = cv2.GaussianBlur(gray, (15, 15), 0)
    difference = np.abs(gray.astype(float) - blurred.astype(float))
    smoothness_score = 1.0 - min(difference.mean() / 10, 1.0)
    return smoothness_score


def _calculate_confidence(image: np.ndarray, gray: np.ndarray) -> float:
    """Calcula confianÃ§a da anÃ¡lise baseada na qualidade da imagem"""
    h, w = gray.shape
    
    # 1. ResoluÃ§Ã£o
    resolution_score = min((h * w) / (640 * 480), 1.0)
    
    # 2. IluminaÃ§Ã£o
    mean_brightness = gray.mean()
    brightness_score = 1.0 - abs(mean_brightness - 128) / 128
    
    # 3. Contraste
    contrast = gray.std()
    contrast_score = min(contrast / 50, 1.0)
    
    # 4. Foco
    laplacian_var = cv2.Laplacian(gray, cv2.CV_64F).var()
    focus_score = min(laplacian_var / 300, 1.0)
    
    confidence = (
        resolution_score * 0.25 +
        brightness_score * 0.25 +
        contrast_score * 0.25 +
        focus_score * 0.25
    )
    
    return confidence


def _get_default_result() -> dict:
    """Resultado padrÃ£o em caso de erro"""
    return {
        "definition_score": 0.5,
        "abs_visibility": 0.5,
        "vascularity": 0.5,
        "muscle_separation": 0.5,
        "subcutaneous_fat": 0.5,
        "central_fat": 0.5,
        "texture_complexity": 0.5,
        "local_contrast": 0.5,
        "confidence": 0.3
    }


def estimate_bf_from_definition(definition_data: dict, sex: str, bmi: float) -> float:
    """
    Estima BF baseado em definiÃ§Ã£o muscular - ðŸ†• V2 CALIBRADO
    
    Melhorias:
    - Thresholds mais rigorosos
    - PenalizaÃ§Ã£o por gordura central
    - Melhor separaÃ§Ã£o entre fÃ­sicos distintos
    """
    
    definition_score = definition_data["definition_score"]
    abs_visibility = definition_data["abs_visibility"]
    vascularity = definition_data["vascularity"]
    central_fat = definition_data.get("central_fat", 0.5)  # ðŸ†• NOVO
    
    # Score combinado ponderado
    visual_score = (
        definition_score * 0.45 +    # Reduzido de 0.50
        abs_visibility * 0.35 +      # Mantido
        vascularity * 0.20           # Aumentado de 0.15
    )
    
    # ðŸ†• PENALIZAÃ‡ÃƒO por gordura central
    if central_fat > 0.6:
        visual_score *= 0.80  # Reduz 20%
    elif central_fat > 0.5:
        visual_score *= 0.90  # Reduz 10%
    
    # ðŸ†• Mapping NÃƒO-LINEAR CALIBRADO
    if sex == "male":
        # ðŸ†• Thresholds mais rigorosos para homens
        if visual_score > 0.80:  # Era 0.75
            bf_estimate = 7 + (1.0 - visual_score) * 25  # 7-12%
        elif visual_score > 0.65:  # Era 0.55
            bf_estimate = 12 + (0.80 - visual_score) * 30  # 12-16.5%
        elif visual_score > 0.45:  # Era 0.35
            bf_estimate = 16.5 + (0.65 - visual_score) * 35  # 16.5-23.5%
        else:
            bf_estimate = 23.5 + (0.45 - visual_score) * 50  # 23.5-46%
    else:
        # ðŸ†• Thresholds mais rigorosos para mulheres
        if visual_score > 0.75:  # Era 0.70
            bf_estimate = 15 + (1.0 - visual_score) * 24  # 15-21%
        elif visual_score > 0.55:  # Era 0.50
            bf_estimate = 21 + (0.75 - visual_score) * 28  # 21-26.6%
        elif visual_score > 0.35:  # Era 0.30
            bf_estimate = 26.6 + (0.55 - visual_score) * 40  # 26.6-34.6%
        else:
            bf_estimate = 34.6 + (0.35 - visual_score) * 50  # 34.6-52.1%
    
    # ðŸ†• AJUSTE FORTE por BMI (sanity check mais rigoroso)
    if bmi < 20 and bf_estimate > 18:
        bf_estimate = 10 + (bmi - 18) * 3  # Mais agressivo
    elif bmi > 30 and bf_estimate < 22:
        bf_estimate = 22 + (bmi - 30) * 2  # Mais agressivo
    
    # ðŸ†• PENALIZAÃ‡ÃƒO ADICIONAL por gordura central alta
    if central_fat > 0.7:
        bf_estimate = min(bf_estimate + 4, 50 if sex == "female" else 45)
    elif central_fat > 0.6:
        bf_estimate = min(bf_estimate + 2, 50 if sex == "female" else 45)
    
    return round(bf_estimate, 1)